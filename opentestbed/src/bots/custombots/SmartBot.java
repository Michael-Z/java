package bots.custombots;

import java.util.LinkedList;

import util.PlayMatrix;

import com.biotools.meerkat.Action;
import com.biotools.meerkat.Card;
import com.biotools.meerkat.GameInfo;
import com.biotools.meerkat.HandEvaluator;
import com.biotools.meerkat.Player;
import com.biotools.meerkat.PlayerInfo;
import com.biotools.meerkat.util.Preferences;

/** 
 * A Simple example bot that can plug into Poker Academy
 * 
 * As an example, the bot has one configuration option -- a check
 * box that, when activated, makes the bot always call.
 * 
 * @author adavidson@poker-academy.com
 */
public class SmartBot implements Player
{

	private int						ourSeat;	// our seat for the current hand
	private Card					c1, c2;	// our hole cards
	private GameInfo				gi;		// general game information
	private Preferences				prefs;		// the configuration options for this bot

	private boolean					didRaise;	// did we raise preflop?
	private LinkedList<PlayerStats>	stats;		//list of all players histories

	private enum stance
	{
		DEFENSIVE,
		AGRESSIVE,
		NEUTRAL
	}

	private stance	curStance;
	PlayMatrix		defensiveTable;
	PlayMatrix		agressiveTable;
	PlayMatrix		neutralTable;
	PlayMatrix		curTable;

	public SmartBot()
	{
		curStance = stance.NEUTRAL;
		defensiveTable = new PlayMatrix();
		defensiveTable.setDefaultMatrix();
		neutralTable = new PlayMatrix();
		neutralTable.setDefaultMatrix();
		agressiveTable = new PlayMatrix();
		agressiveTable.setDefaultMatrix();
		curTable = neutralTable;

		didRaise = false;
		stats = new LinkedList<PlayerStats>();
	}

	/**
	 * An event called to tell us our hole cards and seat number
	 * @param c1 your first hole card
	 * @param c2 your second hole card
	 * @param seat your seat number at the table
	 */
	public void holeCards(Card c1, Card c2, int seat)
	{
		this.c1 = c1;
		this.c2 = c2;
		this.ourSeat = seat;
	}

	/**
	 * Requests an Action from the player
	 * Called when it is the Player's turn to act.
	 */
	public Action getAction()
	{

		if (gi.isPreFlop())
		{
			return preFlopAction();
		}
		else
		{
			return postFlopAction();
		}
	}

	/**
	 * Get the current settings for this bot.
	 */
	public Preferences getPreferences()
	{
		return prefs;
	}

	/**
	 * Load the current settings for this bot.
	 */
	public void init(Preferences playerPrefs)
	{
		this.prefs = playerPrefs;
	}

	/**
	 * @return true if debug mode is on.
	 */
	public boolean getDebug()
	{
		return prefs.getBooleanPreference("DEBUG", false);
	}

	/**
	 * print a debug statement.
	 */
	public void debug(String str)
	{
		if (getDebug())
		{
			System.out.println(str);
		}
	}

	/**
	 * print a debug statement with no end of line character
	 */
	public void debugb(String str)
	{
		if (getDebug())
		{
			System.out.print(str);
		}
	}

	/**
	 * A new betting round has started.
	 */
	public void stageEvent(int stage)
	{
		this.didRaise = false;
	}

	/**
	 * A showdown has occurred.
	 * @param pos the position of the player showing
	 * @param c1 the first hole card shown
	 * @param c2 the second hole card shown
	 */
	public void showdownEvent(int seat, Card c1, Card c2)
	{
	}

	/**
	 * A new game has been started.
	 * @param gi the game stat information
	 */
	public void gameStartEvent(GameInfo gInfo)
	{
		this.gi = gInfo;
	}

	/**
	 * An event sent when all players are being dealt their hole cards
	 */
	public void dealHoleCardsEvent()
	{
	}

	/**
	 * An action has been observed.
	 * In this method, we mine for data about players.
	 * A call bet or raise increases vpmip (voluntarily put money in the pot)
	 * A bet or raise also increases af (aggression factor)
	 */
	public void actionEvent(int pos, Action act)
	{

		PlayerStats player = null;
		int i;

		if (act.getType() < 0 || act.getType() > 4)
		{
			return; // not a type we care about, so dont track it
		}
		for (i = 0; i < stats.size(); i++)
		{
			if (stats.get(i).seat == pos)
			{
				player = stats.get(i);
				break;
			}
		}
		if (player == null || !player.name.equals(gi.getPlayerName(pos)))
		{ // if new name, then new player
			if (player != null)
			{
				stats.remove(i);
			}
			player = new PlayerStats(pos, gi.getPlayerName(pos));
			stats.add(player);
		}
		player.hands++;
		if (act.isBetOrRaise())
		{
			player.putMoney++;
			player.raise++;
		}
		else if (act.isCall())
		{
			player.putMoney++;
		}
	}

	/**
	 * The game info state has been updated
	 * Called after an action event has been fully processed
	 */
	public void gameStateChanged()
	{
	}

	/**
	 * The hand is now over. 
	 */
	public void gameOverEvent()
	{
	}

	/**
	 * A player at pos has won amount with the hand handName
	 */
	public void winEvent(int pos, double amount, String handName)
	{
	}

	/**
	 * Uses table to look up appropriate course of action for hole cards.
	 */
	private Action preFlopAction()
	{
		double toCall = gi.getAmountToCall(ourSeat);

		//note the following action is our Action.class, not theirs
		util.Action action = curTable.getFlopAction(c1, c2);

		if (action == util.Action.FOLD)
		{
			if (toCall == 0)
			{
				return this.call(toCall);
			}
			else
			{
				return Action.foldAction(toCall);
			}
		}
		else if (action == util.Action.LIMP)
		{
			if (toCall == 0)
			{
				return this.call(toCall);
			}
			else if (gi.getNumRaises() != 0)
			{ //does the BB count as a bet?
				return Action.foldAction(toCall);
			}
			else
			{
				if (gi.getNumActivePlayersNotAllIn() <= 6)
				{
					return this.call(toCall);
				}
				else
				{
					return Action.foldAction(toCall);
				}
			}
		}
		else if (action == util.Action.CALL)
		{
			if (toCall == 0)
			{ // we are BB, and no raise
				return Action.callAction(toCall);
			}
			else if (gi.getNumRaises() > 1)
			{ // More than one raise, so fold. does the BB count as a bet?
				return Action.foldAction(toCall);
			}
			else if (gi.getNumRaises() == 0)
			{ // no raises, so call
				return this.call(toCall);
			}
			else
			{ //there is just one raise
				if (toCall <= gi.getBigBlindSize() * 4)
				{ // will call a raise <= 4x BB
					return this.call(toCall);
				}
				else
				{ // fold if the raise is too big (like to 9$ for a 2$ BB
					return Action.foldAction(toCall);
				}
			}
		}
		else if (action == util.Action.RAISE)
		{
			if (gi.getNumRaises() == 0)
			{ //then raise!
				return this.raise(toCall);
			}
			else if (gi.getNumRaises() == 1)
			{ //then call a raise
				if (toCall <= gi.getBigBlindSize() * 5)
				{
					return this.call(toCall);
				}
				else
				{
					return Action.foldAction(toCall);
				}
			}
			else if (gi.getNumRaises() >= 3)
			{ // fold to 4 bets
				return Action.checkOrFoldAction(toCall);
			}
			else if (gi.getNumRaises() == 2 && this.didRaise)
			{ // someone 3 bet our raise
				if (toCall <= gi.getPlayer(ourSeat).getAmountInPotThisRound() * 2.5)
				{
					return this.call(toCall);
				}
			}
		}
		else if (action == util.Action.RERAISE)
		{
			if (gi.getNumRaises() <= 1)
			{ //no raise or one raise so far
				return this.raise(toCall);
			}
			else if (gi.getNumRaises() == 2)
			{ // there is a 3 bet
				if (toCall <= gi.getTotalPotSize() * 0.75)
				{
					return this.call(toCall);
				}
				else
				{
					return Action.checkOrFoldAction(toCall);
				}
			}
		}
		else if (action == util.Action.PREMIUM)
		{
			return this.raise(toCall);
		}
		// should be unreachable
		return Action.checkOrFoldAction(toCall);

	}

	/**
	 * Calls on hands with 50% > x <= 70% of winning
	 * Raise/Bet on hands with x > 70% chance of winning
	 * Goes all in if it knows it has the best hand
	 * Fold all other hands 
	 */
	private Action postFlopAction()
	{
		double toCall = gi.getAmountToCall(ourSeat);
		int numPlayers = gi.getNumActivePlayers();

		// Plays all pocket pairs >= 6
		if (c1.getRank() == c2.getRank())
		{
			if (c1.getRank() >= Card.SIX)
			{
				return Action.callAction(toCall);
			}
		}

		double handRank = HandEvaluator.handRank(c1, c2, gi.getBoard(), numPlayers - 1);

		if (handRank == 1.0)
		{
			// Going all in baby
			return Action.raiseAction(toCall, gi.getBankRoll(ourSeat));
		}
		else if (handRank >= 0.7)
		{
			return Action.raiseAction(gi);
		}
		else if (handRank > 0.5)
		{
			return Action.callAction(toCall);
		}
		else
		{
			return Action.checkOrFoldAction(toCall);
		}
	}

	/**
	 * Changes the stance and also changes curTable to the correct one based on the stance.
	 * @param newStance the stance to set
	 */
	private void changeStance(stance newStance)
	{
		curStance = newStance;
		if (newStance == stance.AGRESSIVE)
		{
			curTable = agressiveTable;
		}
		else if (newStance == stance.NEUTRAL)
		{
			curTable = neutralTable;
		}
		else if (newStance == stance.DEFENSIVE)
		{
			curTable = defensiveTable;
		}
	}

	private Action call(double toCall)
	{ //Aaron's 

		if (toCall >= gi.getPlayer(ourSeat).getBankRoll() / 3)
		{
			this.didRaise = true;
			return Action.raiseAction(toCall, gi.getPlayer(ourSeat).getBankRoll());
		}

		return Action.callAction(toCall);
	}

	private Action raise(double toCall)
	{ //Aaron's

		LinkedList<PlayerInfo> list = new LinkedList<PlayerInfo>();
		double largestStack = 0;
		list = getPlayers();
		for (int i = 0; i < list.size(); i++)
		{
			if (list.get(i).getBankRoll() > largestStack)
			{
				largestStack = list.get(i).getBankRoll();
			}
		}
		if (gi.getNumRaises() == 0)
		{
			if (gi.getBigBlindSize() * 4 > gi.getPlayer(ourSeat).getBankRoll() / 2 || gi.getBigBlindSize() * 4 > largestStack / 2)
			{
				return Action.raiseAction(toCall, gi.getPlayer(ourSeat).getBankRoll());
			}
			else
			{
				return Action.raiseAction(toCall, gi.getBigBlindSize() * 4);
			}
		}
		else
		{
			if (gi.getTotalPotSize() * 2 > gi.getPlayer(ourSeat).getBankRoll() / 2 || gi.getTotalPotSize() * 2 > largestStack / 2)
			{
				return Action.raiseAction(toCall, gi.getPlayer(ourSeat).getBankRoll());
			}
			else
			{
				return Action.raiseAction(toCall, gi.getTotalPotSize() * 2);
			}
		}
	}

	private LinkedList<PlayerInfo> getPlayers()
	{

		LinkedList<PlayerInfo> list = new LinkedList<PlayerInfo>();
		int player = this.ourSeat;
		player = gi.nextActivePlayer(player);
		while (player != this.ourSeat)
		{
			list.add(gi.getPlayer(player));
			player = gi.nextActivePlayer(player);
		}
		return list;
	}

	private class PlayerStats
	{

		int		seat;		// the seat the player is sitting at
		String	name;		// the name of the player
		int		hands;		// how many hands we have seen this player play
		int		raise;		// how many times this player has bet/raised
		int		putMoney;	// how many times this player has put money in the pot voluntarily

		public PlayerStats(int seat, String name)
		{

			this.seat = seat;
			this.name = name;
			hands = raise = putMoney = 0;
		}

	}
}