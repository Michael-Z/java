package bots.AA;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import com.biotools.meerkat.Action;
import com.biotools.meerkat.Card;
import com.biotools.meerkat.GameInfo;
import com.biotools.meerkat.Hand;
import com.biotools.meerkat.Holdem;
import com.biotools.meerkat.Player;
import com.biotools.meerkat.util.Preferences;
import common.handeval.klaatu.PartialStageFastEval;

public class Bigfoot implements Serializable, Player
{
	private int											ourSeat;
	private Card										c1, c2;
	private GameInfo									gi;
	private Preferences									prefs;

	private final boolean								VERBOSE	= false;
	private transient Client							myclient;
	private transient ConcurrentMap<Long, BigFootState>	handid_map;

	public Bigfoot() throws IOException
	{
		try
		{
			this.myclient = new Client(7777, -1, "127.0.0.1", 1);
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		handid_map = new ConcurrentHashMap<Long, BigFootState>();
	}

	public void holeCards(Card c1, Card c2, int seat)
	{

		/**
		 * An event called to tell us our hole cards and seat number
		 * 
		 * @param c1 your first hole card
		 * @param c2 your second hole card
		 * @param seat your seat number at the table
		 */

		this.c1 = c1;
		this.c2 = c2;
		this.ourSeat = seat;
	}

	public Action getAction()
	{
		/**
		 * Requests an Action from the player Called when it is the Player's turn to act.
		 */

		return Get_Decision();
	}

	public Preferences getPreferences()
	{
		/**
		 * Get the current settings for this bot.
		 */

		return prefs;
	}

	public void init(Preferences playerPrefs)
	{
		/**
		 * Load the current settings for this bot.
		 */

		this.prefs = playerPrefs;
	}

	public boolean getDebug()
	{
		/**
		 * @return true if debug mode is on.
		 */

		return prefs.getBooleanPreference("DEBUG", false);
	}

	public void debug(String str)
	{
		/**
		 * print a debug statement.
		 */

		if (getDebug())
		{
			System.out.println(str);
		}
	}

	public void debugb(String str)
	{
		/**
		 * print a debug statement with no end of line character
		 */

		if (getDebug())
		{
			System.out.print(str);
		}
	}

	public void stageEvent(int stage)
	{
		/**
		 * A new betting round has started.
		 */
	}

	public void showdownEvent(int seat, Card c1, Card c2)
	{
		/**
		 * A showdown has occurred.
		 * 
		 * @param pos the position of the player showing
		 * @param c1 the first hole card shown
		 * @param c2 the second hole card shown
		 */
	}

	public void gameStartEvent(GameInfo gInfo)
	{
		/**
		 * A new game has been started.
		 * 
		 * @param gi the game state information
		 */

		this.gi = gInfo;
	}

	public void dealHoleCardsEvent()
	{
		/**
		 * An event sent when all players are being dealt their hole cards
		 */
	}

	public void actionEvent(int pos, Action act)
	{
		/**
		 * An action has been observed.
		 */
	}

	public void gameStateChanged()
	{
		/**
		 * The game info state has been updated Called after an action event has been fully processed
		 */
	}

	public void gameOverEvent()
	{
		/**
		 * The hand is now over.
		 */

		// check what profit we made
		boolean handid_defined = handid_map.containsKey(gi.getGameID());

		if (handid_defined)
		{
			int[] profit = new int[Enums.eDims.Total.getVal()];
			profit[Enums.eProfit.Amt.getVal()] = (int) ((gi.getBankRoll(ourSeat) - 2.0) / gi.getSmallBlindSize());
			profit[Enums.eProfit.handId.getVal()] = handid_map.get(gi.getGameID()).hand_id.intValue();

			if (profit[Enums.eProfit.handId.getVal()] >= 0)
			{
				ExecuteProfitMessageExchange(profit);
				handid_map.remove(gi.getGameID());
			}
			else
				System.out.printf("ERROR - %d HAND_ID INVALID !!!\n", profit[Enums.eProfit.handId.getVal()]);
		}
	}

	public void winEvent(int pos, double amount, String handName)
	{
		/**
		 * A player at pos has won amount with the hand handName
		 */
	}

	private void FillHandArrayPreFlop(int[] hand, BigFootState state)
	{
		// Get betround preflop
		hand[Enums.eDims.brNdx.getVal()] = 0;
		// times acted
		hand[Enums.eDims.timesActed.getVal()] = state.times_acted[0];
		// hand_id
		hand[Enums.eDims.handId.getVal()] = (state.times_acted[0] > 0 ? handid_map.get(gi.getGameID()).hand_id.intValue() : -1);
		// Dealt
		hand[Enums.eDims.Dealt.getVal()] = gi.getNumPlayers();
		// number of players that still need to act
		hand[Enums.eDims.ToAct.getVal()] = gi.getNumToAct();
		// number of players left in the hand (including us) (*)
		hand[Enums.eDims.InHand.getVal()] = gi.getNumActivePlayers();
		// Balance
		hand[Enums.eDims.Balance.getVal()] = (int) (gi.getBankRoll(ourSeat) / gi.getSmallBlindSize());
		// Initial Balance
		hand[Enums.eDims.InitialBalance.getVal()] = 200;
		// amount to call
		hand[Enums.eDims.Call.getVal()] = (int) (gi.getAmountToCall(ourSeat) / gi.getSmallBlindSize());
		// amount in pot
		hand[Enums.eDims.Pot.getVal()] = (int) (gi.getTotalPotSize() / gi.getSmallBlindSize());
		// num raises
		hand[Enums.eDims.Raises.getVal()] = gi.getNumRaises();

		// compute our current hand rank [0...100]
		EnumerateResult result = enumerateHands(c1, c2, gi.getBoard());
		hand[Enums.eDims.HS.getVal()] = (int) (100 * Math.pow(result.HR, hand[Enums.eDims.InHand.getVal()] - 1));
	}

	private void FillHandArrayPostFlop(int[] hand, BigFootState state)
	{
		// constants
		hand[Enums.eDims.brNdx.getVal()] = state.br_ndx;
		hand[Enums.eDims.timesActed.getVal()] = state.times_acted[state.br_ndx];
		// overflow :p
		hand[Enums.eDims.handId.getVal()] = handid_map.get(gi.getGameID()).hand_id.intValue();
		// Dealt
		hand[Enums.eDims.Dealt.getVal()] = gi.getNumPlayers();
		// number of players that still need to act
		hand[Enums.eDims.ToAct.getVal()] = gi.getNumToAct();
		// number of players left in the hand (including us) (*)
		hand[Enums.eDims.InHand.getVal()] = gi.getNumActivePlayers();
		// Initial Balance
		hand[Enums.eDims.InitialBalance.getVal()] = 200;
		// Balance
		hand[Enums.eDims.Balance.getVal()] = (int) (gi.getBankRoll(ourSeat) / gi.getSmallBlindSize());
		// amount to call
		hand[Enums.eDims.Call.getVal()] = (int) (gi.getAmountToCall(ourSeat) / gi.getSmallBlindSize());
		// amount in pot
		hand[Enums.eDims.Pot.getVal()] = (int) (gi.getTotalPotSize() / gi.getSmallBlindSize());
		// num raises
		hand[Enums.eDims.Raises.getVal()] = gi.getNumRaises();

		// compute our current hand rank [0...100]
		EnumerateResult result = enumerateHands(c1, c2, gi.getBoard());
		hand[Enums.eDims.HS.getVal()] = (int) (100 * Math.pow(result.HR, hand[Enums.eDims.InHand.getVal()] - 1));
		// compute a fast approximation of our hand potential, PPot and Npot
		// [0...1]
		hand[Enums.eDims.PPot.getVal()] = 0;
		hand[Enums.eDims.NPot.getVal()] = 0;

		if (gi.getStage() < Holdem.RIVER)
		{
			hand[Enums.eDims.PPot.getVal()] = (int) (100 * result.PPot);
			hand[Enums.eDims.NPot.getVal()] = (int) (100 * result.NPot);
		}
	}

	int ExecuteKnnMessageExchange(int[] hand)
	{
		int bet_type = Enums.eBets.eUnknown.getVal();
		int recv_msgtype = Enums.eMessageType.eMsgUnknown.getVal();
		int[] recv_buffer = new int[Enums.eDims.Total.getVal()];

		// send 1 : knn request - send the hand array directly
		hand[Enums.eDims.RequestType.getVal()] = Enums.eMessageType.eClientKnnRequest.getVal();
		try
		{
			myclient.SendInts(hand, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// recv 2: Wait for eServerKnnReply
		recv_msgtype = Enums.eMessageType.eMsgUnknown.getVal();
		java.util.Arrays.fill(recv_buffer, 0);
		try
		{
			myclient.RecvInts(recv_buffer, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// check if messages are different or of unexpected type
		recv_msgtype = recv_buffer[Enums.eDims.RequestType.getVal()];
		if (recv_msgtype != Enums.eMessageType.eServerKnnReply.getVal())
		{
			System.out.printf("ERROR: Expecting eServerKnnReply [Got %d]\n", recv_msgtype);
			return -1;
		}

		// We are done :)
		bet_type = recv_buffer[Enums.eDims.Decision.getVal()];

		return bet_type;
	}

	int ExecuteHandUpdateMessageExchange(int[] hand)
	{
		int inserted_hand_id = -1;
		int recv_msgtype = Enums.eMessageType.eMsgUnknown.getVal();
		int[] recv_buffer = new int[Enums.eDims.Total.getVal()];

		// SEND 1
		hand[Enums.eDims.RequestType.getVal()] = Enums.eMessageType.eClientSaveHandRequest.getVal();
		try
		{
			myclient.SendInts(hand, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// RECV 2
		java.util.Arrays.fill(recv_buffer, 0);
		try
		{
			myclient.RecvInts(recv_buffer, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// check if messages are different or of unexpected type
		recv_msgtype = recv_buffer[Enums.eDims.RequestType.getVal()];
		if (Enums.eMessageType.eServerInsertedHandID.getVal() != recv_msgtype)
		{
			System.out.printf("ERROR: Expecting eServerInsertedID [Got %d]\n", recv_msgtype);
			return -1;
		}

		inserted_hand_id = recv_buffer[Enums.eDims.handId.getVal()];
		//System.out.printf(">>> Inserted hand %d\n", inserted_hand_id);

		return inserted_hand_id;
	}

	int ExecuteProfitMessageExchange(int[] profit)
	{
		int inserted_hand_id = -1;
		int recv_msgtype;
		int[] recv_buffer = new int[Enums.eDims.Total.getVal()];

		// send 1 : profit request
		profit[Enums.eProfit.RequestType.getVal()] = Enums.eMessageType.eClientSaveProfit.getVal();
		if (handid_map.containsKey(gi.getGameID()))
			profit[Enums.eProfit.handId.getVal()] = (int) handid_map.get(gi.getGameID()).hand_id.intValue();
		else
			profit[Enums.eProfit.handId.getVal()] = -1;

		// SEND 1
		try
		{
			myclient.SendInts(profit, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// RECV 2
		try
		{
			myclient.RecvInts(recv_buffer, Enums.eDims.Total.getVal());
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// check if messages are different or of unexpected type
		recv_msgtype = recv_buffer[Enums.eProfit.RequestType.getVal()];
		if (Enums.eMessageType.eServerInsertedProfitHandID.getVal() != recv_msgtype)
		{
			System.out.printf("ERROR: Expecting eServerInsertedID [Got %s]\n", recv_msgtype);
			return -1;
		}

		inserted_hand_id = recv_buffer[Enums.eProfit.handId.getVal()];
		if (VERBOSE)
			System.out.printf("PROFIT : %d\n", recv_buffer[Enums.eProfit.handId.getVal()]);

		return inserted_hand_id;
	}

	private double TranslateActionToAmt(Enums.eBets betType)
	{
		double amt = 0.0;
		double pot = gi.getTotalPotSize();
		double call = gi.getAmountToCall(ourSeat);

		switch (betType)
		{
			case eFold:
				break;
			case eCheck:
				break;
			case eCall:
				amt = call;
				break;
			case eHalfPot:
				amt = call + 0.5 * pot;
				break;
			case ePot:
				amt = call + pot;
				break;
			case eTwoPots:
				amt = call + 2.0 * pot;
				break;
			default:
				break;
		}

		return (amt > gi.getBankRoll(ourSeat) ? gi.getBankRoll(ourSeat) : amt);
	}

	private int GetBR()
	{
		if (gi.isPreFlop())
			return 0;
		else if (gi.isFlop())
			return 1;
		else if (gi.isTurn())
			return 2;
		else if (gi.isRiver())
			return 3;

		return -1;
	}

	private Action Get_Decision()
	{

		Action ret;
		int[] hand = new int[Enums.eDims.Total.getVal()];

		BigFootState bf_state = null;
		if (handid_map.containsKey(gi.getGameID()))
			bf_state = handid_map.get(gi.getGameID());
		else
			bf_state = new BigFootState();

		bf_state.br_ndx = GetBR();

		// Fill hand[]
		if (0 == bf_state.br_ndx)
			FillHandArrayPreFlop(hand, bf_state);
		else
			FillHandArrayPostFlop(hand, bf_state);

		// previous actions
		if (Math.min(hand[Enums.eDims.timesActed.getVal()], 3) >= 1)
		{
			for (int i = 0; i < Math.min(hand[Enums.eDims.timesActed.getVal()], 4); i++)
				hand[Enums.eDims.Action1.getVal() + i] = bf_state.curr_actions[i];
		}

		// Get decision from master
		int dec = Enums.eBets.eUnknown.getVal();
		dec = ExecuteKnnMessageExchange(hand);

		// hmmm ... will lead to problems - FIX ME
		if (Enums.eBets.eCheck.getVal() >= dec)
			ret = Action.checkOrFoldAction(gi.getAmountToCall(ourSeat));
		else if (Enums.eBets.eCall.getVal() == dec)
			ret = Action.callAction(gi);
		else
		{
			double wantedRaiseAmount = TranslateActionToAmt(Enums.eBets.values()[dec]);
			ret = Action.raiseAction(gi, wantedRaiseAmount);
		}

		// Stupid fix for when times_acted >= k_max_actions
		// Just call here and avoid errors
		if (bf_state.times_acted[bf_state.br_ndx] == 3 && dec > Enums.eBets.eCall.getVal())
		{
			dec = Enums.eBets.eCall.getVal();
			ret = Action.callAction(gi);
		}

		// current action
		hand[Enums.eDims.Action1.getVal() + Math.min(hand[Enums.eDims.timesActed.getVal()], 3)] = dec;

		// Save hand
		bf_state.hand_id = (long) ExecuteHandUpdateMessageExchange(hand);
		bf_state.curr_actions[bf_state.times_acted[bf_state.br_ndx]] = dec;
		bf_state.times_acted[bf_state.br_ndx]++;
		bf_state.new_hand = false;

		if (VERBOSE)
			System.out.printf(">>> %d - hand_id: %d\n", gi.getGameID(), (long) bf_state.hand_id);

		if (!handid_map.containsKey(gi.getGameID()))
		{
			if (bf_state.hand_id > 0)
				handid_map.put(gi.getGameID(), bf_state);
			else
				System.out.printf("ERROR - Invalid Hand ID Saving hand: %d", bf_state.hand_id);
		}

		return ret;

	}

	/**
	 * Calculate the raw (unweighted) PPot1 and NPot1 of a hand. (Papp 1998, 5.3) Does a one-card look ahead.
	 * 
	 * @param c1 the first hole card
	 * @param c2 the second hole card
	 * @param bd the board cards
	 * @return
	 */
	public EnumerateResult enumerateHands(Card c1, Card c2, Hand bd)
	{
		double[][] HP = new double[3][3];
		double[] HPTotal = new double[3];
		int ourrank7, opprank;
		int index;
		int[] boardIndexes = new int[bd.size()];
		int[] boardIndexes2 = new int[bd.size() + 1];
		int c1Index;
		int c2Index;

		ArrayList<Integer> deck = new ArrayList<Integer>();
		for (int i = 0; i < 52; i++)
		{
			deck.add(Integer.valueOf(i));
		}
		for (int i = 0; i < bd.size(); i++)
		{
			Card card = bd.getCard(i + 1);
			boardIndexes[i] = PartialStageFastEval.encode(card.getRank(), card.getSuit());
			boardIndexes2[i] = PartialStageFastEval.encode(card.getRank(), card.getSuit());
			deck.remove(Integer.valueOf(boardIndexes[i]));
		}

		c1Index = PartialStageFastEval.encode(c1.getRank(), c1.getSuit());
		c2Index = PartialStageFastEval.encode(c2.getRank(), c2.getSuit());
		deck.remove(Integer.valueOf(c1Index));
		deck.remove(Integer.valueOf(c2Index));

		int ourrank5 = eval(boardIndexes, c1Index, c2Index);

		// pick first opponent card
		for (int i = 0; i < deck.size(); i++)
		{
			int o1Card = deck.get(i);
			// pick second opponent card
			for (int j = i + 1; j < deck.size(); j++)
			{
				int o2Card = deck.get(j);
				opprank = eval(boardIndexes, o1Card, o2Card);
				if (ourrank5 > opprank)
					index = AHEAD;
				else if (ourrank5 == opprank)
					index = TIED;
				else
					index = BEHIND;
				HPTotal[index]++;
				if (bd.size() < 5)
				{

					// tally all possiblities for next board card
					for (int k = 0; k < deck.size(); k++)
					{
						if (i == k || j == k)
							continue;
						boardIndexes2[boardIndexes2.length - 1] = deck.get(k);
						ourrank7 = eval(boardIndexes2, c1Index, c2Index);
						opprank = eval(boardIndexes2, o1Card, o2Card);
						if (ourrank7 > opprank)
							HP[index][AHEAD]++;
						else if (ourrank7 == opprank)
							HP[index][TIED]++;
						else
							HP[index][BEHIND]++;
					}
				}
			}
		} /* end of possible opponent hands */

		double den1 = (45 * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));
		double den2 = (45 * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));
		EnumerateResult result = new EnumerateResult();
		if (den1 > 0)
		{
			result.PPot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED] / 2.0) + (HP[TIED][AHEAD] / 2.0)) / (double) den1;
		}
		if (den2 > 0)
		{
			result.NPot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED] / 2.0) + (HP[TIED][BEHIND] / 2.0)) / (double) den2;
		}
		result.HR = (HPTotal[AHEAD] + (HPTotal[TIED] / 2)) / (HPTotal[AHEAD] + HPTotal[TIED] + HPTotal[BEHIND]);

		return result;
	}

	private int eval(int[] boardIndexes, int c1Index, int c2Index)
	{
		if (boardIndexes.length == 5)
		{
			return PartialStageFastEval.eval7(boardIndexes[0], boardIndexes[1], boardIndexes[2], boardIndexes[3], boardIndexes[4], c1Index,
					c2Index);
		}
		else if (boardIndexes.length == 4)
		{
			return PartialStageFastEval.eval6(boardIndexes[0], boardIndexes[1], boardIndexes[2], boardIndexes[3], c1Index, c2Index);
		}
		else if (boardIndexes.length == 3)
		{
			return PartialStageFastEval.eval5(boardIndexes[0], boardIndexes[1], boardIndexes[2], c1Index, c2Index);
		}
		else
		{
			return PartialStageFastEval.encode(c1Index, c2Index);
		}
	}

	// constants used in above method:
	private final static int	AHEAD	= 0;
	private final static int	TIED	= 1;
	private final static int	BEHIND	= 2;

	class EnumerateResult
	{
		double	HR;
		double	PPot;
		double	NPot;
	}

}